<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Lazyflow Request Framework &#8212; lazyflow 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="lazyflow 0.1 documentation" href="index.html" />
    <link rel="next" title="Utilities" href="utilities.html" />
    <link rel="prev" title="Advanced Concepts" href="advanced.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="utilities.html" title="Utilities"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Advanced Concepts"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">lazyflow 0.1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lazyflow-request-framework">
<span id="request-framework"></span><h1><a class="toc-backref" href="#id4">Lazyflow Request Framework</a><a class="headerlink" href="#lazyflow-request-framework" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#lazyflow-request-framework" id="id4">Lazyflow Request Framework</a><ul>
<li><a class="reference internal" href="#introduction" id="id5">Introduction</a></li>
<li><a class="reference internal" href="#quick-start" id="id6">Quick Start</a></li>
<li><a class="reference internal" href="#dependencies" id="id7">Dependencies</a></li>
<li><a class="reference internal" href="#cancellation" id="id8">Cancellation</a><ul>
<li><a class="reference internal" href="#handling-cancellation" id="id9">Handling Cancellation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#failed-requests" id="id10">Failed Requests</a><ul>
<li><a class="reference internal" href="#exception-propagation" id="id11">Exception Propagation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#request-notifications" id="id12">Request Notifications</a><ul>
<li><a class="reference internal" href="#callback-timing-guarantee" id="id13">Callback Timing Guarantee</a></li>
</ul>
</li>
<li><a class="reference internal" href="#synchronization-primitives" id="id14">Synchronization Primitives</a></li>
<li><a class="reference internal" href="#debugging-features" id="id15">Debugging Features</a><ul>
<li><a class="reference internal" href="#synchronous-requests" id="id16">Synchronous Requests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-details" id="id17">Implementation Details</a><ul>
<li><a class="reference internal" href="#threadpool" id="id18">ThreadPool</a></li>
<li><a class="reference internal" href="#thread-context-consistency-guarantee" id="id19">Thread Context Consistency Guarantee</a></li>
<li><a class="reference internal" href="#request-lifetime" id="id20">Request Lifetime</a></li>
<li><a class="reference internal" href="#optimization-direct-execution" id="id21">Optimization: Direct Execution</a></li>
<li><a class="reference internal" href="#foreign-thread-context-vs-request-context" id="id22">Foreign Thread Context vs. Request Context</a></li>
<li><a class="reference internal" href="#request-priority" id="id23">Request Priority</a></li>
<li><a class="reference internal" href="#old-api-backwards-compatibility" id="id24">Old API Backwards Compatibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-reference" id="id25">Class Reference</a><ul>
<li><a class="reference internal" href="#request" id="id26">Request</a></li>
<li><a class="reference internal" href="#requestlock" id="id27">RequestLock</a></li>
<li><a class="reference internal" href="#simplerequestcondition" id="id28">SimpleRequestCondition</a></li>
<li><a class="reference internal" href="#requestpool" id="id29">RequestPool</a></li>
<li><a class="reference internal" href="#id3" id="id30">ThreadPool</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id5">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The request framework is a general-purpose, coroutine-based task scheduling system based on the <a class="reference external" href="http://pypi.python.org/pypi/greenlet">greenlet</a> python library.
It does not depend in any way on the graph framework, so it could be used to schedule the execution of generic python callables.
It is similar in spirit to other greenlet-based frameworks like <a class="reference external" href="http://eventlet.net">eventlet</a> and <a class="reference external" href="http://www.gevent.org">gevent</a>, which provide a similar interface for
highly concurrent IO applications.</p>
<p>Using the lazyflow request framework, it is easy to perform concurrent, asynchronous workloads, without requiring the developer
to write complicated state-machines or messy callback handlers.  The request framework hides this complexity from the developer,
allowing you to write in a clean, blocking <em>style</em> without the performance drag of actually blocking the OS thread(s) your workload is executing on.
Internally, requests are scheduled for execution in a fixed-size threadpool.  When a request has to wait for subcomputations to
complete in other requests, it is temporarily suspended so that its OS thread can be used to perform other work.</p>
<p>This dependency diagram shows how user-defined workloads depend on the parts of the request system.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_framework_structure.svg"><img alt="request framework dependencies" src="_images/request_framework_structure.svg" /></a>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The request framework is written to allow easy parallelization of computations.
In Python, the <em>Global Interpreter Lock</em> (GIL) prevents the interpreter from executing two python statements at once.
This restriction does not apply to C or C++ extensions (as long as they release the GIL).
Therefore, the Request framework is most useful for workloads that do most of their &#8220;heavy lifting&#8221; within C/C++ extensions.
For pure Python workloads, the Request Framework doesn&#8217;t provide performance benefits, but may still be useful for the abstractions it provides.</p>
</div>
</div>
<div class="section" id="quick-start">
<span id="id1"></span><h2><a class="toc-backref" href="#id6">Quick Start</a><a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s start with an example computation.  Suppose you want to smooth an image at two different scales, then subtract the two resulting images.
A naive implementation of this computation might look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">some_img_lib</span> <span class="kn">import</span> <span class="n">smooth</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigmaA</span><span class="p">,</span> <span class="n">sigmaB</span><span class="p">):</span>
    <span class="n">smoothedA</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigmaA</span><span class="p">)</span>
    <span class="n">smoothedB</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigmaB</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">smoothedA</span> <span class="o">-</span> <span class="n">smoothedB</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="n">diff_of_smoothed</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">my_image</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>
</pre></div>
</div>
<p>The above single-threaded approach leaves much room for improvement.  Using the request framework, we can parallelize the workload:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">some_img_lib</span> <span class="kn">import</span> <span class="n">smooth</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">lazyflow.request</span> <span class="kn">import</span> <span class="n">Request</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigmaA</span><span class="p">,</span> <span class="n">sigmaB</span><span class="p">):</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">smooth</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sigmaA</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">r3</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">smooth</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sigmaB</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1"># Start executing r3</span>
    <span class="n">r3</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>

    <span class="c1"># Wait until both requests are complete</span>
    <span class="n">smoothedA</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span> <span class="c1"># (Auto-submits)</span>
    <span class="n">smoothedB</span> <span class="o">=</span> <span class="n">r3</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">smoothedA</span> <span class="o">-</span> <span class="n">smoothedB</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="n">r1</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">my_image</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="p">)</span>
<span class="n">diff_of_smoothed</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>To understand the example, we make a few key observations:</p>
<ul class="simple">
<li>Request objects are constructed with a single callable object, which it executes</li>
<li>Requests do not execute their callable until they have been submitted via <code class="docutils literal"><span class="pre">Request.submit()</span></code>.</li>
<li><code class="docutils literal"><span class="pre">Request.wait()</span></code> automatically calls <code class="docutils literal"><span class="pre">submit()</span></code> if the request hasn&#8217;t been submitted yet.</li>
<li>The callable&#8217;s return value is given as the result of <code class="docutils literal"><span class="pre">Request.wait()</span></code>.</li>
<li><code class="docutils literal"><span class="pre">functools.partial</span></code> (from the python standard library) is a convenient way of creating a new callable object from a function and a set of arguments.</li>
</ul>
<p>In cases where we are creating multiple requests and waiting until they are all complete, we can use a RequestPool, which eliminates some boilerplate.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">some_img_lib</span> <span class="kn">import</span> <span class="n">smooth</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">lazyflow.request</span> <span class="kn">import</span> <span class="n">Request</span><span class="p">,</span> <span class="n">RequestPool</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigmaA</span><span class="p">,</span> <span class="n">sigmaB</span><span class="p">):</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">smooth</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sigmaA</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">r3</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">smooth</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sigmaB</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">pool</span> <span class="o">=</span> <span class="n">RequestPool</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">r2</span> <span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">r3</span> <span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">r2</span><span class="o">.</span><span class="n">result</span> <span class="o">-</span> <span class="n">r3</span><span class="o">.</span><span class="n">result</span>

<span class="n">r1</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">my_image</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="p">)</span>
<span class="n">diff_of_smoothed</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>Okay, in our example, only two of the requests can execute in parallel, so the RequestPool didn&#8217;t save any code in this case.
Anyway, we have more observations to make note of:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">RequestPool.wait()</span></code> will block until all requests in the pool have completed.</li>
<li>All Request objects save their callable&#8217;s return value as an attribute: <code class="docutils literal"><span class="pre">Request.result</span></code></li>
</ul>
</div>
<div class="section" id="dependencies">
<h2><a class="toc-backref" href="#id7">Dependencies</a><a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h2>
<p>Here&#8217;s a visualization of the dependencies between the requests from the quickstart example:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_dependency.svg"><img alt="request dependency diagram" src="_images/request_dependency.svg" /></a>
</div>
<p>As you can see, r1 depends on BOTH r2 and r3.  In a typical use case, request dependencies form a tree, but this isn&#8217;t always true.
Let&#8217;s tweak our example even further.  In the new version, we don&#8217;t already have the input image.  Instead, we compute it in a separate request.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">some_img_lib</span> <span class="kn">import</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">compute_sample_image</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">lazyflow.request</span> <span class="kn">import</span> <span class="n">Request</span><span class="p">,</span> <span class="n">RequestPool</span>

<span class="k">def</span> <span class="nf">waitAndSmooth</span><span class="p">(</span> <span class="n">imageRequest</span><span class="p">,</span> <span class="n">sigma</span> <span class="p">):</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">imageRequest</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">smooth</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">imageRequest</span><span class="p">,</span> <span class="n">sigmaA</span><span class="p">,</span> <span class="n">sigmaB</span><span class="p">):</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">waitAndSmooth</span><span class="p">,</span> <span class="n">imageRequest</span><span class="p">,</span> <span class="n">sigmaA</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">r3</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">waitAndSmooth</span><span class="p">,</span> <span class="n">imageRequest</span><span class="p">,</span> <span class="n">sigmaB</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">pool</span> <span class="o">=</span> <span class="n">RequestPool</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">r2</span> <span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">r3</span> <span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">r2</span><span class="o">.</span><span class="n">result</span> <span class="o">-</span> <span class="n">r3</span><span class="o">.</span><span class="n">result</span>

<span class="n">r4</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">compute_sample_image</span> <span class="p">)</span>
<span class="n">r1</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">r4</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="p">)</span>
<span class="n">diff_of_smoothed</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>Now our example is getting a little contrived for such a simple computation, but bear with us.
The request dependencies are visualized in the following diagram:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_dependency_shared.svg"><img alt="request dependency diagram" src="_images/request_dependency_shared.svg" /></a>
</div>
</div>
<div class="section" id="cancellation">
<h2><a class="toc-backref" href="#id8">Cancellation</a><a class="headerlink" href="#cancellation" title="Permalink to this headline">¶</a></h2>
<p>The request framework is designed to support interactive GUIs, in which the computational workload may need to be altered on the fly.
In such an environment, it may be necessary to <em>cancel</em> a request that has already been submitted.</p>
<p>To cancel a request, simply call <code class="docutils literal"><span class="pre">Request.cancel()</span></code></p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">r1</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">some_work</span> <span class="p">)</span>
<span class="n">r1</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>

<span class="c1"># ...</span>

<span class="n">r1</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</pre></div>
</div>
<p>If the request was waiting for any other requests, those requests will be cancelled, too.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">some_work</span><span class="p">():</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">some_more_work</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">r2</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

<span class="n">r1</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">some_work</span> <span class="p">)</span>
<span class="n">r1</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>

<span class="c1"># ...</span>

<span class="n">r1</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span> <span class="c1"># Cancels r1 AND r2.</span>
</pre></div>
</div>
<p>But a request will not be cancelled unless ALL of the requests that were waiting for it have already been cancelled.
For example, suppose the dependency graph for some group of requests looked like this:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_cancellation_example_before.svg"><img alt="request dependency diagram" src="_images/request_cancellation_example_before.svg" /></a>
</div>
<p>Now suppose that we call <code class="docutils literal"><span class="pre">r1.cancel()</span></code>.  The following diagram shows all cancelled requests in red.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_cancellation_example_after.svg"><img alt="request dependency diagram" src="_images/request_cancellation_example_after.svg" /></a>
</div>
<p>Notice that r3 and subsequent requests were <strong>not</strong> cancelled because there is a non-cancelled request (r2) still waiting for it.</p>
<div class="section" id="handling-cancellation">
<h3><a class="toc-backref" href="#id9">Handling Cancellation</a><a class="headerlink" href="#handling-cancellation" title="Permalink to this headline">¶</a></h3>
<p>Within the context of a request, cancellation produces an exception.  When a request has been cancelled, nothing happens at first.
As soon as the request cedes control to the Request framework by calling <code class="docutils literal"><span class="pre">Request.wait()</span></code> on a child request, a cancellation request is raised.
In a typical application, requests are used to execute pure functional callables.  For pure-functional requests, there&#8217;s no need to handle the cancellation exception.
However, in some applications, you may want to use requests to modify some external state.
In that case, you&#8217;ll need to handle the cancellation exception that might be raised any time your request calls <code class="docutils literal"><span class="pre">wait()</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">global_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">add_items_to_global_list</span><span class="p">(</span> <span class="n">num_items</span> <span class="p">):</span>
    <span class="n">initial_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">global_list</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_items</span><span class="p">):</span>
            <span class="n">req</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">get_next_item</span> <span class="p">)</span>
            <span class="n">next_item</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span> <span class="c1"># Might raise</span>
            <span class="n">global_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">next_item</span> <span class="p">)</span>
    <span class="k">except</span> <span class="n">Request</span><span class="o">.</span><span class="n">CancellationException</span><span class="p">:</span>
        <span class="c1"># Restore the previous global state</span>
        <span class="n">global_list</span> <span class="o">=</span> <span class="n">global_list</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">initial_size</span><span class="p">]</span>
        <span class="k">raise</span>

<span class="n">r1</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">add_items_to_global_list</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="n">r1</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>

<span class="c1"># ...</span>

<span class="n">r1</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span> <span class="c1"># Cancels r1 AND r2.</span>
</pre></div>
</div>
<p>In the example above, we catch the <code class="docutils literal"><span class="pre">Request.CancellationException</span></code> that might be raised within <code class="docutils literal"><span class="pre">req.wait()</span></code>.
Note that we <strong>re-raise</strong> the exception after we clean up.  Re-raising the cancellation exception isn&#8217;t strictly
required by the current Request framework implementation, but it is considered best practice nonetheless.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a special corner case that can occur if your request attempts to wait for a request that has <em>already been cancelled</em> from some other thread or request.
If you attempt to wait for a request that is already cancelled, a <code class="docutils literal"><span class="pre">Request.InvalidRequestException</span></code> is raised.</p>
</div>
</div>
</div>
<div class="section" id="failed-requests">
<h2><a class="toc-backref" href="#id10">Failed Requests</a><a class="headerlink" href="#failed-requests" title="Permalink to this headline">¶</a></h2>
<p>If any exception is raised within a request (other than a cancellation exception), the request fails.
The exception that caused the failure is propagated to the request(s) or thread(s) that are waiting for it.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">some_work</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Something went wrong.&quot;</span><span class="p">)</span>

<span class="n">r1</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">some_work</span> <span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">r1</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">(</span><span class="s2">&quot;Request failed.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Request failure handling and exception propagation is relatively heavy-weight.
You can and should rely on it to catch occasional or unexpected failures, but do not rely
on it as though it were as cheap as a simple if/else statement.  If your requests are
repeatedly raising and catching exceptions, your performance may suffer.</p>
</div>
<div class="section" id="exception-propagation">
<h3><a class="toc-backref" href="#id11">Exception Propagation</a><a class="headerlink" href="#exception-propagation" title="Permalink to this headline">¶</a></h3>
<p>As mentioned above, exceptions raised in a request are propagated backwards to waiting requests.
There is an interesting consequence of this behavior: For the special case where a request is being waited on by multiple requests,
a single exception may propagate through multiple callstacks.</p>
<p>Consider this request dependency graph:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_exception_propagation_before.svg"><img alt="request dependency diagram" src="_images/request_exception_propagation_before.svg" /></a>
</div>
<p>Suppose an exception is raised in r1.  The following series of diagrams highlights the requests in which the exception will be seen.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_exception_propagation_before.svg"><img alt="request dependency diagram" src="_images/request_exception_propagation_before.svg" /></a>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_exception_propagation_step1.svg"><img alt="request dependency diagram" src="_images/request_exception_propagation_step1.svg" /></a>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_exception_propagation_step2.svg"><img alt="request dependency diagram" src="_images/request_exception_propagation_step2.svg" /></a>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_exception_propagation_step3.svg"><img alt="request dependency diagram" src="_images/request_exception_propagation_step3.svg" /></a>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_exception_propagation_step4.svg"><img alt="request dependency diagram" src="_images/request_exception_propagation_step4.svg" /></a>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_exception_propagation_step5.svg"><img alt="request dependency diagram" src="_images/request_exception_propagation_step5.svg" /></a>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>We are missing an optimzation opportunity here.  In the example above, one of the right-most requests
never sees the exception.
That&#8217;s expected behavior, since that request did not fail.  But after the exception is propagated
through the request &#8220;call&#8221; stacks, the request is not needed any more.  To save CPU cycles, we
could <em>cancel</em> the non-failed children of failed requests.</p>
<p class="last">If we decide to implement this optimization, we should take care not to interfere with the status of
the children that have already failed.  Only the non-failed requests should be cancelled, to avoid
downgrading the &#8220;failed&#8221; status of some requests into a &#8220;cancelled&#8221; status.</p>
</div>
</div>
</div>
<div class="section" id="request-notifications">
<h2><a class="toc-backref" href="#id12">Request Notifications</a><a class="headerlink" href="#request-notifications" title="Permalink to this headline">¶</a></h2>
<p>For some use-cases, you may want to be notified when a request completes.  Request objects allow you to subscribe callbacks to three notifications:</p>
<ul class="simple">
<li>Use <code class="docutils literal"><span class="pre">Request.notify_finished()</span></code> to be notified when a request completes <strong>successfully</strong>.</li>
<li>Use <code class="docutils literal"><span class="pre">Request.notify_failed()</span></code> to be notified when a request has <strong>failed</strong> (due to an uncaught exception).</li>
<li>Use <code class="docutils literal"><span class="pre">Request.notify_cancelled()</span></code> to be notified when a request has been <strong>cancelled</strong>.</li>
</ul>
<p>Here&#8217;s an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">some_work</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Do some work.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">handle_result</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">print</span> <span class="s2">&quot;The result was:&quot;</span><span class="p">,</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">handle_failure</span><span class="p">(</span><span class="n">ex</span><span class="p">):</span>
    <span class="k">print</span> <span class="s2">&quot;The request failed due a {} exception&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="p">)</span>

<span class="k">def</span> <span class="nf">handle_cancelled</span><span class="p">():</span>
    <span class="k">print</span> <span class="s2">&quot;The request was cancelled&quot;</span>

<span class="n">req</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">some_work</span> <span class="p">)</span>
<span class="n">req</span><span class="o">.</span><span class="n">notify_finished</span><span class="p">(</span> <span class="n">handle_result</span> <span class="p">)</span>
<span class="n">req</span><span class="o">.</span><span class="n">notify_failed</span><span class="p">(</span> <span class="n">handle_failure</span> <span class="p">)</span>
<span class="n">req</span><span class="o">.</span><span class="n">notify_cancelled</span><span class="p">(</span> <span class="n">handle_cancelled</span> <span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">req</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="k">print</span> <span class="s2">&quot;Request is no longer executing.&quot;</span>
</pre></div>
</div>
<div class="section" id="callback-timing-guarantee">
<h3><a class="toc-backref" href="#id13">Callback Timing Guarantee</a><a class="headerlink" href="#callback-timing-guarantee" title="Permalink to this headline">¶</a></h3>
<p>If you&#8217;re paying very close attention, you might be thinking of a question:</p>
<p>Does <code class="docutils literal"><span class="pre">Request.wait()</span></code> return <strong>before</strong> or <strong>after</strong> the callbacks are notified?
In other words, after I <code class="docutils literal"><span class="pre">wait()</span></code> for a request, is it guaranteed that my callbacks have finished executing?</p>
<p>Answer:</p>
<ul class="simple">
<li>Callbacks that were subscribed (via <code class="docutils literal"><span class="pre">notify_finished</span></code>, <code class="docutils literal"><span class="pre">notify_failed</span></code>, <code class="docutils literal"><span class="pre">notify_cancelled</span></code>)
<em>before</em> the call to <code class="docutils literal"><span class="pre">Request.wait()</span></code> are <em>guaranteed</em> to be called before <code class="docutils literal"><span class="pre">Request.wait()</span></code> returns.</li>
<li>Callbacks that are subscribed <em>after</em> you call <code class="docutils literal"><span class="pre">Request.wait()</span></code> will eventually be called,
but the timing of the notification is <strong>not</strong> guaranteed to be before <code class="docutils literal"><span class="pre">Request.wait()</span></code> returns.</li>
</ul>
</div>
</div>
<div class="section" id="synchronization-primitives">
<h2><a class="toc-backref" href="#id14">Synchronization Primitives</a><a class="headerlink" href="#synchronization-primitives" title="Permalink to this headline">¶</a></h2>
<p>Concurrent requests share the same pool of OS threads.
The usual <code class="docutils literal"><span class="pre">Lock</span></code> and <code class="docutils literal"><span class="pre">RLock</span></code> objects from the python standard <code class="docutils literal"><span class="pre">threading</span></code> module
will <strong>not</strong> function as intended within the context of a Request.**
The Request Framework provides an alternative lock, which <strong>can</strong> be used within a Request.
The <a class="reference internal" href="#lazyflow.request.RequestLock" title="lazyflow.request.RequestLock"><code class="xref py py-class docutils literal"><span class="pre">RequestLock</span></code></a> class has the same API as
<code class="docutils literal"><span class="pre">threading.Lock</span></code>, and can be used as a drop-in replacement.
See the <a class="reference internal" href="#lazyflow.request.RequestLock" title="lazyflow.request.RequestLock"><code class="xref py py-class docutils literal"><span class="pre">RequestLock</span></code></a> documentation for further details.
Also see the <a class="reference internal" href="#lazyflow.request.SimpleRequestCondition" title="lazyflow.request.SimpleRequestCondition"><code class="xref py py-class docutils literal"><span class="pre">SimpleRequestCondition</span></code></a> documentation for a <code class="docutils literal"><span class="pre">threading.Condition</span></code>-like class.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">**Actually, <code class="docutils literal"><span class="pre">threading.Lock</span></code> <em>can</em> be used within a Request if used very carefully.
As long as <code class="docutils literal"><span class="pre">wait()</span></code> is not called while the lock is held, there is no increased risk of deadlock or unexpected race conditions.
The <code class="docutils literal"><span class="pre">ResultLock</span></code> class relieves the developer of this constraint, so it should be favored over <code class="docutils literal"><span class="pre">threading.Lock</span></code>.</p>
</div>
</div>
<div class="section" id="debugging-features">
<h2><a class="toc-backref" href="#id15">Debugging Features</a><a class="headerlink" href="#debugging-features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="synchronous-requests">
<h3><a class="toc-backref" href="#id16">Synchronous Requests</a><a class="headerlink" href="#synchronous-requests" title="Permalink to this headline">¶</a></h3>
<p>If you&#8217;re using an interactive debugger like the one in PyDev/Eclipse, it can be hard to figure out <em>where</em> a particular request came from.  Often, the current thread&#8217;s stack is truncated because it&#8217;s executing inside a worker thread.  The original request which &#8220;spawned&#8221; the problematic one is probably suspended or running in a separate thread.</p>
<p>For debugging purposes, the lazyflow request system can be forced in a special single-threaded mode, in which all requests execute synchronously within the calling thread.  (Specifically, they are executed when my_request.submit() is called.)  If you&#8217;re wondering &#8220;how did I end up in this function?&#8221;, try re-running your test in single-threaded mode, and just use your debugger to follow the stack frames down to the root cause.</p>
<p>To activate this mode in a unit test, set the size of the lazyflow worker thread pool to 0 threads:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lazyflow.request</span> <span class="kn">import</span> <span class="n">Request</span>
<span class="n">Request</span><span class="o">.</span><span class="n">reset_thread_pool</span><span class="p">(</span><span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Or when debugging in ilastik, change the <code class="docutils literal"><span class="pre">[lazyflow]/threads</span></code> config file setting:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>[ilastik]
debug: true
plugin_directories: ~/Documents/workspace/object_feature_plugins

[lazyflow]
total_ram_mb: 8000
threads: 0
</pre></div>
</div>
<p>Alternatively, use this environment variable when launching ilastik:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">LAZYFLOW_THREADS</span><span class="o">=</span><span class="m">0</span> python ilastik.py
</pre></div>
</div>
</div>
</div>
<div class="section" id="implementation-details">
<h2><a class="toc-backref" href="#id17">Implementation Details</a><a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<p>This section is of interest to developers who need to maintain or experiment with the implementation of the Request Framework.</p>
<div class="section" id="threadpool">
<h3><a class="toc-backref" href="#id18">ThreadPool</a><a class="headerlink" href="#threadpool" title="Permalink to this headline">¶</a></h3>
<p>As indicated in the dependency diagram in the introduction, the ThreadPool class is an independent module.
In fact, since it does not depend on the rest of the Request Framework in any way, it could be useful as a general thread pool utility for other applications.
Tasks are added to the ThreadPool via <code class="docutils literal"><span class="pre">ThreadPool.wake_up()</span></code>.  At first, they sit in a queue of tasks that is shared by all Worker threads.
Each Worker thread keeps its own queue of tasks to execute.  When a Worker&#8217;s task queue becomes empty, it pulls a task from the shared queue.</p>
</div>
<div class="section" id="thread-context-consistency-guarantee">
<span id="thread-context-guarantee"></span><h3><a class="toc-backref" href="#id19">Thread Context Consistency Guarantee</a><a class="headerlink" href="#thread-context-consistency-guarantee" title="Permalink to this headline">¶</a></h3>
<p>For simple tasks (e.g. plain functions), that&#8217;s the end of the story.  For more complicated cases (e.g. requests, generators, etc.) that may
be woken up multiple times, the <code class="docutils literal"><span class="pre">ThreadPool</span></code> provides an important guarantee: a given task will always execute on the SAME Worker thread, every time
it is woken up.  The Worker thread chosen for a particular task is arbitrary for the first time it is woken up, but it will return to the same
Worker thread for each subsequent call to <code class="docutils literal"><span class="pre">wake_up()</span></code>.  This guarantee is essential for coroutine based tasks based on greenlets (e.g. all Requests).</p>
</div>
<div class="section" id="request-lifetime">
<h3><a class="toc-backref" href="#id20">Request Lifetime</a><a class="headerlink" href="#request-lifetime" title="Permalink to this headline">¶</a></h3>
<p>We&#8217;ll use the following diagram to track the state of a request throughout its lifetime.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_blank.svg"><img alt="empty request lifetime diagram" src="_images/request_lifetime_blank.svg" /></a>
</div>
<p>Let&#8217;s consider the first example we used in the <a class="reference internal" href="#quick-start"><span class="std std-ref">Quick Start</span></a> section from above:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">some_img_lib</span> <span class="kn">import</span> <span class="n">smooth</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">lazyflow.request</span> <span class="kn">import</span> <span class="n">Request</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigmaA</span><span class="p">,</span> <span class="n">sigmaB</span><span class="p">):</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">smooth</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sigmaA</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">r3</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">smooth</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sigmaB</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1"># Start executing r3</span>
    <span class="n">r3</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>

    <span class="c1"># Wait until both requests are complete</span>
    <span class="n">smoothedA</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span> <span class="c1"># (Auto-submits)</span>
    <span class="n">smoothedB</span> <span class="o">=</span> <span class="n">r3</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">smoothedA</span> <span class="o">-</span> <span class="n">smoothedB</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="n">r1</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">my_image</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="p">)</span>
<span class="n">diff_of_smoothed</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>The first request is created on this line:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">r1</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">my_image</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Since it hasn&#8217;t been submitted yet, it isn&#8217;t yet known to the ThreadPool:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r1_not_submitted.svg"><img alt="r1 not yet submitted" src="_images/request_lifetime_r1_not_submitted.svg" /></a>
</div>
<hr class="docutils" />
<p>The next line (implicitly) submits the request and immediately blocks for it.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">diff_of_smoothed</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>When the request is submitted, it is given to the ThreadPool.  Since the ThreadPool hasn&#8217;t seen this request previously, it ends up in the shared task queue.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r1_unassigned.svg"><img alt="r1 not yet submitted" src="_images/request_lifetime_r1_unassigned.svg" /></a>
</div>
<hr class="docutils" />
<p>Next, it is picked up by one of the ThreadPool&#8217;s worker threads:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r1_executing_A.svg"><img alt="r1 executing" src="_images/request_lifetime_r1_executing_A.svg" /></a>
</div>
<hr class="docutils" />
<p>When r1 starts executing, it creates two new requests:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">r2</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">smooth</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sigmaA</span><span class="p">)</span> <span class="p">)</span>
<span class="n">r3</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">partial</span><span class="p">(</span><span class="n">smooth</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sigmaB</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r2_r3_not_submitted.svg"><img alt="r2 and r3 not yet submitted" src="_images/request_lifetime_r2_r3_not_submitted.svg" /></a>
</div>
<hr class="docutils" />
<p>First, it submits r3:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Start executing r3</span>
<span class="n">r3</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>
</pre></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r3_submitted.svg"><img alt="r1 not yet submitted" src="_images/request_lifetime_r3_submitted.svg" /></a>
</div>
<p>...which is eventually picked up by a ThreadPool Worker thread:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r3_executing_A.svg"><img alt="r3 executing" src="_images/request_lifetime_r3_executing_A.svg" /></a>
</div>
<hr class="docutils" />
<p>For the sake of illustration, let&#8217;s suppose that some other part of our app has also just submitted some requests:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_extra_requests_submitted.svg"><img alt="r2 submitted" src="_images/request_lifetime_extra_requests_submitted.svg" /></a>
</div>
<hr class="docutils" />
<p>Back in r1, we submit and wait for r2.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">smoothedA</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span> <span class="c1"># (Auto-submits)</span>
</pre></div>
</div>
<p>This happens in two steps.  First, r2 is submitted:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r2_submitted.svg"><img alt="r2 submitted" src="_images/request_lifetime_r2_submitted.svg" /></a>
</div>
<p>Next, r1 is <em>suspended</em> (since it is now waiting for r2).</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r1_suspended.svg"><img alt="r1 suspended" src="_images/request_lifetime_r1_suspended.svg" /></a>
</div>
<hr class="docutils" />
<p>This next step exhibits the advantage of the Request Framework over a simple ThreadPool.
Since r1 has been suspended, it <em>no longer ties up a Thread</em>.
The newly available worker now picks up a request from the shared queue:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r1_suspended_B.svg"><img alt="r1 suspended" src="_images/request_lifetime_r1_suspended_B.svg" /></a>
</div>
<hr class="docutils" />
<p>Eventually, each request either completes or is suspended, and r2 makes it to the front of the shared queue:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r2_front_of_queue.svg"><img alt="r1 suspended" src="_images/request_lifetime_r2_front_of_queue.svg" /></a>
</div>
<p>...and gets picked up by a free worker:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r2_executing.svg"><img alt="r1 suspended" src="_images/request_lifetime_r2_executing.svg" /></a>
</div>
<hr class="docutils" />
<p>Meanwhile, r3 finishes execution:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r3_finished.svg"><img alt="r1 suspended" src="_images/request_lifetime_r3_finished.svg" /></a>
</div>
<hr class="docutils" />
<p>After a while, suppose other requests (from other parts of the app) continue to be submitted:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r2_executing_other_requests_woken.svg"><img alt="r2 executing, other requests woken" src="_images/request_lifetime_r2_executing_other_requests_woken.svg" /></a>
</div>
<hr class="docutils" />
<p>Eventually, r2 finishes execution:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r2_finished.svg"><img alt="r2 finished" src="_images/request_lifetime_r2_finished.svg" /></a>
</div>
<hr class="docutils" />
<p>Since r2 and r3 are both complete, r1 can finally be woken up again:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r1_woken_up.svg"><img alt="r1 woken up" src="_images/request_lifetime_r1_woken_up.svg" /></a>
</div>
<p>The last figure shows something important.  Did you catch it?  When r1 was <strong>initially</strong> submitted to the ThreadPool, it didn&#8217;t matter which Worker was chosen to execute it in.
But now that it is being re-awoken, it <strong>must</strong> execute on the same Worker that it used previously.
It is not added to the ThreadPool&#8217;s shared queue.
Also, it does not execute on the second worker thread, even though (in our example) that thread happens to be unoccupied at the moment.
It is added to the first worker&#8217;s queue.  This is a constraint imposed by the greenlet package, which is used to implement Request coroutines.
See also: <a class="reference internal" href="#thread-context-guarantee"><span class="std std-ref">Thread Context Consistency Guarantee</span></a>.</p>
<hr class="docutils" />
<p>When the first worker becomes free, r1 can finally resume execution:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r1_executing_B.svg"><img alt="r1 executing again" src="_images/request_lifetime_r1_executing_B.svg" /></a>
</div>
<p>...and eventually r1 finishes execution.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/request_lifetime_r1_finished.svg"><img alt="r1 finished" src="_images/request_lifetime_r1_finished.svg" /></a>
</div>
</div>
<div class="section" id="optimization-direct-execution">
<h3><a class="toc-backref" href="#id21">Optimization: Direct Execution</a><a class="headerlink" href="#optimization-direct-execution" title="Permalink to this headline">¶</a></h3>
<p>From the user&#8217;s perspective, calling <code class="docutils literal"><span class="pre">req.wait()</span></code> is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">req</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>
<span class="n">req</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>But under the hood, the Request framework uses an optimization for the case where <code class="docutils literal"><span class="pre">req.wait()</span></code> is called on a request that hasn&#8217;t been submitted yet.
Instead of submitting the request to the ThreadPool, the request is simply executed <em>synchronously</em>.
There is no need to incur the overhead of creating a new greenlet, queueing the request, and so on.
With this optimization, we don&#8217;t have to pay a significant penalty for using requests in cases where no parallelism was needed in the first place.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This optimization avoids some overhead of starting new requests in their own greenlets, but it has a side-effect worth noting:
When a subrequest is directly executed, it &#8220;skips in line&#8221;.  It does not sit in the ThreadPool shared queue.
It is executed immediately, even if higher priority requests are waiting in the shared queue.
Before experimenting with alternative request prioritization schemes, it might be worth disabling this optimization.</p>
</div>
</div>
<div class="section" id="foreign-thread-context-vs-request-context">
<h3><a class="toc-backref" href="#id22">Foreign Thread Context vs. Request Context</a><a class="headerlink" href="#foreign-thread-context-vs-request-context" title="Permalink to this headline">¶</a></h3>
<p>Internally, the Request Framework distinguishes between two types of execution contexts: <code class="docutils literal"><span class="pre">request.RequestGreenlet</span></code> and &#8220;normal&#8221; a.k.a &#8220;foreign&#8221; threads.
If a Request is waited upon from within a foreign thread, we don&#8217;t attempt to suspend the foreign thread.
Instead, we simply use a regular threading.Event to wait for the Request to complete.
The current context is obtained by calling the classmethod <code class="docutils literal"><span class="pre">Request.current_request()</span></code>.  It returns <code class="docutils literal"><span class="pre">None</span></code> if the current context is a &#8220;foreign&#8221; thread.</p>
</div>
<div class="section" id="request-priority">
<h3><a class="toc-backref" href="#id23">Request Priority</a><a class="headerlink" href="#request-priority" title="Permalink to this headline">¶</a></h3>
<p>The queue class used by the <code class="docutils literal"><span class="pre">ThreadPool</span></code> can be easily configured.  One of the options is a priority queue, in which tasks are ordered according to their implementation of <code class="docutils literal"><span class="pre">__lt__</span></code>.
Requests are prioritized according to a simple rule: whichever request has the oldest ancestor (i.e. the request that spawned it) has higher priority.
If two requests have a common ancestor, then their next-oldest ancestors are compared, and so on.  This way, we hope to avoid cache and RAM thrashing that might be
encountered if newer requests were to &#8220;cut in line&#8221; in front of older requests, preventing the old requests from finishing as quickly as possible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This prioritization scheme is simple, and could maybe be improved.  Fortunately, the ThreadPool class is written to allow easy experimentation with different queueing schemes.</p>
</div>
</div>
<div class="section" id="old-api-backwards-compatibility">
<h3><a class="toc-backref" href="#id24">Old API Backwards Compatibility</a><a class="headerlink" href="#old-api-backwards-compatibility" title="Permalink to this headline">¶</a></h3>
<p>As a temporary convenience for migration to the latest version of the Request Framework, a few methods from the old API have been provided:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Request.getResult()</span></code> (now replaced with <code class="docutils literal"><span class="pre">Request.result</span></code>)</li>
<li><code class="docutils literal"><span class="pre">Request.writeInto()</span></code> (This member is specific to the Lazyflow Graph Framework.  It will soon be implemented there, in a special subclass of <code class="docutils literal"><span class="pre">Request</span></code>.)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Backwards-compatibility support will be removed soon.
If you are depending on the old API, please upgrade your code.</p>
</div>
</div>
</div>
<div class="section" id="class-reference">
<h2><a class="toc-backref" href="#id25">Class Reference</a><a class="headerlink" href="#class-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="request">
<span id="id2"></span><h3><a class="toc-backref" href="#id26">Request</a><a class="headerlink" href="#request" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="lazyflow.request.Request">
<em class="property">class </em><code class="descclassname">lazyflow.request.</code><code class="descname">Request</code><span class="sig-paren">(</span><em>fn, root_priority=[0]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="lazyflow.request.Request.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>fn, root_priority=[0]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor.
Postconditions: The request has the same cancelled status as its parent (the request that is creating this one).</p>
</dd></dl>

<dl class="exception">
<dt id="lazyflow.request.Request.CancellationException">
<em class="property">exception </em><code class="descname">CancellationException</code><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.CancellationException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.CancellationException" title="Permalink to this definition">¶</a></dt>
<dd><p>This is raised when the whole request has been cancelled.
If you catch this exception from within a request, clean up and return immediately.
If you have nothing to clean up, you are not required to handle this exception.</p>
<p>Implementation details:
This exception is raised when the cancel flag is checked in the wait() function:
- immediately before the request is suspended OR
- immediately after the request is woken up from suspension</p>
</dd></dl>

<dl class="exception">
<dt id="lazyflow.request.Request.CircularWaitException">
<em class="property">exception </em><code class="descclassname">Request.</code><code class="descname">CircularWaitException</code><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.CircularWaitException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.CircularWaitException" title="Permalink to this definition">¶</a></dt>
<dd><p>This exception is raised if a request calls wait() on itself.
Currently, this only catches the most basic case.
No attempt is made to detect indirect cycles
(e.g. if req.wait() is called from within a req&#8217;s own child.),
so don&#8217;t rely on it to catch tricky deadlocks due to indirect self-waiting.</p>
</dd></dl>

<dl class="exception">
<dt id="lazyflow.request.Request.InternalError">
<em class="property">exception </em><code class="descclassname">Request.</code><code class="descname">InternalError</code><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.InternalError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.InternalError" title="Permalink to this definition">¶</a></dt>
<dd><p>This is raised if an error is detected in the Request framework itself.
If this exception is raised, it implies a bug in this file (request.py).</p>
</dd></dl>

<dl class="exception">
<dt id="lazyflow.request.Request.InvalidRequestException">
<em class="property">exception </em><code class="descclassname">Request.</code><code class="descname">InvalidRequestException</code><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.InvalidRequestException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.InvalidRequestException" title="Permalink to this definition">¶</a></dt>
<dd><p>This is raised when calling wait on a request that has already been cancelled,
which can only happen if the request you&#8217;re waiting for was spawned elsewhere 
(i.e. you are waiting for someone else&#8217;s request to avoid duplicate work).
When this occurs, you will typically want to restart the request yourself.</p>
</dd></dl>

<dl class="exception">
<dt id="lazyflow.request.Request.TimeoutException">
<em class="property">exception </em><code class="descclassname">Request.</code><code class="descname">TimeoutException</code><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.TimeoutException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.TimeoutException" title="Permalink to this definition">¶</a></dt>
<dd><p>This is raised if a call to wait() times out in the context of a foreign thread.
See <code class="docutils literal"><span class="pre">Request.wait()</span></code> for details.</p>
</dd></dl>

<dl class="attribute">
<dt id="lazyflow.request.Request.assigned_worker">
<code class="descclassname">Request.</code><code class="descname">assigned_worker</code><a class="headerlink" href="#lazyflow.request.Request.assigned_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>This member is accessed by the ThreadPool to determine which Worker thread this request belongs to.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.Request.block">
<code class="descclassname">Request.</code><code class="descname">block</code><span class="sig-paren">(</span><em>timeout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.block" title="Permalink to this definition">¶</a></dt>
<dd><p>Like wait, but does not return a result.  Can be used even if the request has already been cleaned.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.Request.cancel">
<code class="descclassname">Request.</code><code class="descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.cancel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to cancel this request and all requests that it spawned.
No request will be cancelled if other non-cancelled requests are waiting for its results.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.Request.clean">
<code class="descclassname">Request.</code><code class="descname">clean</code><span class="sig-paren">(</span><em>_fullClean=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.clean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete all state from the request, for cleanup purposes.
Removes references to callbacks, children, and the result.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>_fullClean</strong> &#8211; Internal use only.  If False, only clean internal bookkeeping members.
Otherwise, delete everything, including the result.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="lazyflow.request.Request.current_request_is_cancelled">
<em class="property">classmethod </em><code class="descclassname">Request.</code><code class="descname">current_request_is_cancelled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.current_request_is_cancelled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.current_request_is_cancelled" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if called from within the context of a cancelled request.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.Request.notify_cancelled">
<code class="descclassname">Request.</code><code class="descname">notify_cancelled</code><span class="sig-paren">(</span><em>fn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.notify_cancelled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.notify_cancelled" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback function to be called when this request is finished due to cancellation.
If we&#8217;re already finished and cancelled, call it now.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fn</strong> &#8211; The callback to call if the request is cancelled.  Signature: fn()</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.Request.notify_failed">
<code class="descclassname">Request.</code><code class="descname">notify_failed</code><span class="sig-paren">(</span><em>fn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.notify_failed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.notify_failed" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback function to be called when this request is finished due to failure (an exception was raised).
If we&#8217;re already failed, call it now.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fn</strong> &#8211; The callback to call if the request fails.  Signature: <code class="docutils literal"><span class="pre">fn(exception,</span> <span class="pre">exception_info)</span></code>
exception_info is a tuple of (type, value, traceback). See Python documentation on
<code class="docutils literal"><span class="pre">sys.exc_info()</span></code> for more documentation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.Request.notify_finished">
<code class="descclassname">Request.</code><code class="descname">notify_finished</code><span class="sig-paren">(</span><em>fn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.notify_finished"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.notify_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a callback function to be called when this request is finished.
If we&#8217;re already finished, call it now.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fn</strong> &#8211; The callback to be notified.  Signature: fn(result)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="lazyflow.request.Request.raise_if_cancelled">
<em class="property">classmethod </em><code class="descclassname">Request.</code><code class="descname">raise_if_cancelled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.raise_if_cancelled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.raise_if_cancelled" title="Permalink to this definition">¶</a></dt>
<dd><p>If called from the context of a cancelled request, raise a CancellationException immediately.</p>
</dd></dl>

<dl class="classmethod">
<dt id="lazyflow.request.Request.reset_thread_pool">
<em class="property">classmethod </em><code class="descclassname">Request.</code><code class="descname">reset_thread_pool</code><span class="sig-paren">(</span><em>num_workers=8</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.reset_thread_pool"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.reset_thread_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the number of threads allocated to the request system.</p>
<p>As a special case, you may set <code class="docutils literal"><span class="pre">num_workers</span></code> to 0.  
In that case, the normal thread pool is not used at all.  
Instead, all requests will execute synchronously, from within the submitting thread.  
Utilities like <code class="docutils literal"><span class="pre">RequestLock</span></code>, <code class="docutils literal"><span class="pre">SimpleRequestCondition</span></code> will use alternate 
implementations based on equivalent classes in the builtin <code class="docutils literal"><span class="pre">threading</span></code> module.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is only valid to call this function during startup.
Any existing requests will be dropped from the pool!</p>
</div>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.Request.submit">
<code class="descclassname">Request.</code><code class="descname">submit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.submit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.submit" title="Permalink to this definition">¶</a></dt>
<dd><p>If this request isn&#8217;t started yet, schedule it to be started.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.Request.wait">
<code class="descclassname">Request.</code><code class="descname">wait</code><span class="sig-paren">(</span><em>timeout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#Request.wait"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.Request.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Start this request if necessary, then wait for it to complete.  Return the request&#8217;s result.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timeout</strong> &#8211; If running within a request, this parameter must be None.
If running within the context of a foreign (non-request) thread, 
a timeout may be specified in seconds (floating-point).
If the request does not complete within the timeout period, 
then a Request.TimeoutException is raised.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="requestlock">
<h3><a class="toc-backref" href="#id27">RequestLock</a><a class="headerlink" href="#requestlock" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="lazyflow.request.RequestLock">
<em class="property">class </em><code class="descclassname">lazyflow.request.</code><code class="descname">RequestLock</code><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestLock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Request-aware lock.  Implements the same interface as threading.Lock.
If acquire() is called from a normal thread, the the lock blocks the thread as usual.
If acquire() is called from a Request, then the request is suspended so that another Request can be resumed on the thread.</p>
<p>Requests and normal threads can <em>share</em> access to a RequestLock.
That is, they compete equally for access to the lock.</p>
<p>Implementation detail:  Depends on the ability to call two <em>private</em> Request methods: _suspend() and _wake_up().</p>
<dl class="class">
<dt id="lazyflow.request.RequestLock.RequestLockQueue">
<em class="property">class </em><code class="descname">RequestLockQueue</code><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestLock.RequestLockQueue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestLock.RequestLockQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>This data structure is a pseudo-priority queue.
If you&#8217;re not ready to process the highest-priority item, you can simply push it back.
It will be placed in a secondary queue while you continue to process other items.</p>
<p>Two priority queues are maintained: one for pushing, one for popping.
Items are popped from the &#8216;popping queue&#8217; until it is empty, and then the two
queues are swapped.</p>
<p>Suppose you pop an item (the highest priority item), but you discover you&#8217;re not
able to use it immediately for some reason (e.g. it&#8217;s a request that is still
waiting for a lock). Hence, you simply &#8216;push&#8217; it back into this data structure.</p>
<p>If there were only one queue, it would end up a the front of the queue again (it was the
highest priority item, after all).</p>
<p>That is, you would never make any progress on the queue because you would just pop and
push the same item over and over!</p>
<p>But since this data structure uses TWO queues, the pushed item will be put on the
&#8216;pushing queue&#8217; instead and, it won&#8217;t be popped again until the popping queue is depleted
(at which point the two queues are swapped).</p>
<p>With this scheme, high-priority requests can opt not to monopolize access to a lock if
they need to wait for lower-priority requests to complete before continuing.
This is important for code involving condition variables, for instance.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.RequestLock.acquire">
<code class="descclassname">RequestLock.</code><code class="descname">acquire</code><span class="sig-paren">(</span><em>blocking=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestLock.acquire"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestLock.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the lock.  If <cite>blocking</cite> is True, block until the lock is available.
If <cite>blocking</cite> is False, don&#8217;t wait and return False if the lock couldn&#8217;t be acquired immediately.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>blocking</strong> &#8211; Same as in threading.Lock</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.RequestLock.locked">
<code class="descclassname">RequestLock.</code><code class="descname">locked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestLock.locked"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestLock.locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if lock is currently held by some thread or request.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.RequestLock.release">
<code class="descclassname">RequestLock.</code><code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestLock.release"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestLock.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the lock so that another request or thread can acquire it.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="simplerequestcondition">
<h3><a class="toc-backref" href="#id28">SimpleRequestCondition</a><a class="headerlink" href="#simplerequestcondition" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="lazyflow.request.SimpleRequestCondition">
<em class="property">class </em><code class="descclassname">lazyflow.request.</code><code class="descname">SimpleRequestCondition</code><a class="reference internal" href="_modules/lazyflow/request/request.html#SimpleRequestCondition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.SimpleRequestCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>A <code class="docutils literal"><span class="pre">Request</span></code>-compatible condition variable that supports a limited
subset of the features implemented by the standard <code class="docutils literal"><span class="pre">threading.Condition</span></code>.</p>
<p><strong>Limitations:</strong></p>
<ul class="simple">
<li>Only one request may call <a class="reference internal" href="#lazyflow.request.SimpleRequestCondition.wait" title="lazyflow.request.SimpleRequestCondition.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> at a time.</li>
<li>Likewise, <a class="reference internal" href="#lazyflow.request.SimpleRequestCondition.notify" title="lazyflow.request.SimpleRequestCondition.notify"><code class="xref py py-meth docutils literal"><span class="pre">notify()</span></code></a> doesn&#8217;t accept the <code class="docutils literal"><span class="pre">n</span></code> arg.</li>
<li>Likewise, there is no <code class="docutils literal"><span class="pre">notify_all()</span></code> method.</li>
<li><a class="reference internal" href="#lazyflow.request.SimpleRequestCondition.wait" title="lazyflow.request.SimpleRequestCondition.wait"><code class="xref py py-meth docutils literal"><span class="pre">wait()</span></code></a> doesn&#8217;t support the <code class="docutils literal"><span class="pre">timeout</span></code> arg.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It would be nice if we could simply use <code class="docutils literal"><span class="pre">threading.Condition(</span> <span class="pre">RequestLock()</span> <span class="pre">)</span></code> instead of rolling 
our own custom condition variable class, but that doesn&#8217;t quite work in cases where we need to call 
<code class="docutils literal"><span class="pre">wait()</span></code> from a worker thread (a non-foreign thread).
(<code class="docutils literal"><span class="pre">threading.Condition</span></code> uses <code class="docutils literal"><span class="pre">threading.Lock()</span></code> as its &#8216;waiter&#8217; lock, which blocks the entire worker.)</p>
</div>
<p><strong>Example:</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">cond</span> <span class="o">=</span> <span class="n">SimpleRequestCondition</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">process_all_data</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">cond</span><span class="p">:</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">all_finished</span><span class="p">:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">is_data_chunk_ready</span><span class="p">():</span>
                <span class="n">cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="n">all_finished</span> <span class="o">=</span> <span class="n">process_available_data</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">retrieve_some_data</span><span class="p">():</span>
    <span class="n">get_some_data</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">cond</span><span class="p">:</span>
        <span class="n">cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>

<span class="n">req1</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">retrieve_some_data</span> <span class="p">)</span>
<span class="n">req2</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">retrieve_some_data</span> <span class="p">)</span>
<span class="n">req3</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span> <span class="n">retrieve_some_data</span> <span class="p">)</span>

<span class="n">req1</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>
<span class="n">req2</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>
<span class="n">req3</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>

<span class="c1"># Wait for them all to finish...</span>
<span class="n">process_all_data</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="lazyflow.request.SimpleRequestCondition.notify">
<code class="descname">notify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#SimpleRequestCondition.notify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.SimpleRequestCondition.notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Notify the condition that it can stop <code class="docutils literal"><span class="pre">wait()</span></code>-ing.
The called <strong>must</strong> own (acquire) the condition before calling this method.
Also, the waiting request cannot return from <code class="docutils literal"><span class="pre">wait()</span></code> until the condition is released, 
so the caller should generally release the condition shortly after calling this method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is okay to call this from more than one request in parallel.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.SimpleRequestCondition.wait">
<code class="descname">wait</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#SimpleRequestCondition.wait"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.SimpleRequestCondition.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for another request to call py:meth:<code class="docutils literal"><span class="pre">notify()</span></code>.  
The caller <strong>must</strong> own (acquire) the condition before calling this method.
The condition is automatically <code class="docutils literal"><span class="pre">released()</span></code> while this method waits for 
<code class="docutils literal"><span class="pre">notify()</span></code> to be called, and automatically <code class="docutils literal"><span class="pre">acquired()</span></code> again before returning.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike <code class="docutils literal"><span class="pre">threading.Condition</span></code>, it is <strong>NOT</strong> valid to call <code class="docutils literal"><span class="pre">wait()</span></code> 
from multiple requests in parallel.  That is, this class supports only 
one &#8216;consumer&#8217; thread.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike <code class="docutils literal"><span class="pre">threading.Condition</span></code>, no <code class="docutils literal"><span class="pre">timeout</span></code> parameter is accepted here.</p>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="requestpool">
<h3><a class="toc-backref" href="#id29">RequestPool</a><a class="headerlink" href="#requestpool" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="lazyflow.request.RequestPool">
<em class="property">class </em><code class="descclassname">lazyflow.request.</code><code class="descname">RequestPool</code><span class="sig-paren">(</span><em>max_active=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestPool"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestPool" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for submitting a batch of requests and waiting until they are all complete.
Requests cannot be added to the pool after it has already started.
Not threadsafe:</p>
<blockquote>
<div><ul class="simple">
<li>don&#8217;t call add() from more than one thread</li>
<li>don&#8217;t call wait() from more than one thread, but you CAN add requests
that are already executing in a different thread to a requestpool</li>
</ul>
</div></blockquote>
<dl class="exception">
<dt id="lazyflow.request.RequestPool.RequestPoolError">
<em class="property">exception </em><code class="descname">RequestPoolError</code><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestPool.RequestPoolError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestPool.RequestPoolError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised if you attempt to use the Pool in a manner that it isn&#8217;t designed for.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.RequestPool.add">
<code class="descclassname">RequestPool.</code><code class="descname">add</code><span class="sig-paren">(</span><em>req</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestPool.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestPool.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a request to the pool.  The pool must not be submitted yet.  Otherwise, an exception is raised.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.RequestPool.cancel">
<code class="descclassname">RequestPool.</code><code class="descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestPool.cancel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestPool.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel all requests in the pool.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.RequestPool.clean">
<code class="descclassname">RequestPool.</code><code class="descname">clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestPool.clean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestPool.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Release our handles to all requests in the pool, for cleanup purposes.
There is no need to call this yourself.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.RequestPool.request">
<code class="descclassname">RequestPool.</code><code class="descname">request</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestPool.request"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestPool.request" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated method</strong>.
Convenience function to construct a request for the given callable and add it to the pool.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.RequestPool.wait">
<code class="descclassname">RequestPool.</code><code class="descname">wait</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/request.html#RequestPool.wait"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.RequestPool.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Launch all requests and return after they have all completed, including their callback handlers.</p>
<p>First, N requests are launched (N=_max_active).
As each one completes, launch a new request to replace it until
there are no unsubmitted requests remaining.</p>
<p>The block() function is called on every request after it has completed, to ensure
that any exceptions from those requests are re-raised by the RequestPool.</p>
<p>(If we didn&#8217;t block for &#8216;finishing&#8217; requests at all, we&#8217;d be violating the Request &#8216;Callback Timing Guarantee&#8217;, 
which must hold for <em>both</em> Requests and RequestPools.  See Request docs for details.)</p>
<p>After that, each request is discarded, so that it&#8217;s reference dies immediately
and any memory it consumed is reclaimed.</p>
<p>So, requests fall into four categories:</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>unsubmitted</dt>
<dd><p class="first last">Not started yet.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>active</dt>
<dd><p class="first last">Currently running their main workload</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>finishing</dt>
<dd><p class="first last">Main workload complete, but might still be running callback handlers.
We will call block() on these to ensure they have finished with callbacks,
and then discard them.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>discarded</dt>
<dd><p class="first last">After each request is processed in _clear_finishing_requests(), it is removed from the
&#8216;finishing&#8217; set and the RequestPool retains no references to it any more.</p>
</dd>
</dl>
</li>
</ol>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id30">ThreadPool</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="lazyflow.request.threadPool.ThreadPool">
<em class="property">class </em><code class="descclassname">lazyflow.request.threadPool.</code><code class="descname">ThreadPool</code><span class="sig-paren">(</span><em>num_workers</em>, <em>queue_type=&lt;class 'lazyflow.utility.priorityQueue.PriorityQueue'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/threadPool.html#ThreadPool"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.threadPool.ThreadPool" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages a set of worker threads and dispatches tasks to them.</p>
<dl class="method">
<dt id="lazyflow.request.threadPool.ThreadPool.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>num_workers</em>, <em>queue_type=&lt;class 'lazyflow.utility.priorityQueue.PriorityQueue'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/threadPool.html#ThreadPool.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.threadPool.ThreadPool.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor.  Starts all workers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_workers</strong> &#8211; The number of worker threads to create.</li>
<li><strong>queue_type</strong> &#8211; The type of queue to use for prioritizing tasks.  Possible queue types include <a class="reference internal" href="#lazyflow.request.threadPool.PriorityQueue" title="lazyflow.request.threadPool.PriorityQueue"><code class="xref py py-class docutils literal"><span class="pre">PriorityQueue</span></code></a>,
<code class="xref py py-class docutils literal"><span class="pre">FifoQueue</span></code>, and <code class="xref py py-class docutils literal"><span class="pre">LifoQueue</span></code>, or any class with <code class="docutils literal"><span class="pre">push()</span></code>, <code class="docutils literal"><span class="pre">pop()</span></code>, and <code class="docutils literal"><span class="pre">__len__()</span></code> methods.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.threadPool.ThreadPool.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/threadPool.html#ThreadPool.stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.threadPool.ThreadPool.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop all threads in the pool, and block for them to complete.
Postcondition: All worker threads have stopped.  Unfinished tasks are simply dropped.</p>
</dd></dl>

<dl class="method">
<dt id="lazyflow.request.threadPool.ThreadPool.wake_up">
<code class="descname">wake_up</code><span class="sig-paren">(</span><em>task</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lazyflow/request/threadPool.html#ThreadPool.wake_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.threadPool.ThreadPool.wake_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Schedule the given task on the worker that is assigned to it.
If it has no assigned worker yet, assign it to the first worker that becomes available.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lazyflow.request.threadPool.PriorityQueue">
<em class="property">class </em><code class="descclassname">lazyflow.request.threadPool.</code><code class="descname">PriorityQueue</code><a class="reference internal" href="_modules/lazyflow/utility/priorityQueue.html#PriorityQueue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lazyflow.request.threadPool.PriorityQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>Threadsafe priority queue based on the python heapq module.</p>
<p>Ties are resolved by popping the element that was added first. If
the elements are tuples (p1, p2, ..., element), the elements are
never considered for comparison!</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Lazyflow Request Framework</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#quick-start">Quick Start</a></li>
<li><a class="reference internal" href="#dependencies">Dependencies</a></li>
<li><a class="reference internal" href="#cancellation">Cancellation</a><ul>
<li><a class="reference internal" href="#handling-cancellation">Handling Cancellation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#failed-requests">Failed Requests</a><ul>
<li><a class="reference internal" href="#exception-propagation">Exception Propagation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#request-notifications">Request Notifications</a><ul>
<li><a class="reference internal" href="#callback-timing-guarantee">Callback Timing Guarantee</a></li>
</ul>
</li>
<li><a class="reference internal" href="#synchronization-primitives">Synchronization Primitives</a></li>
<li><a class="reference internal" href="#debugging-features">Debugging Features</a><ul>
<li><a class="reference internal" href="#synchronous-requests">Synchronous Requests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-details">Implementation Details</a><ul>
<li><a class="reference internal" href="#threadpool">ThreadPool</a></li>
<li><a class="reference internal" href="#thread-context-consistency-guarantee">Thread Context Consistency Guarantee</a></li>
<li><a class="reference internal" href="#request-lifetime">Request Lifetime</a></li>
<li><a class="reference internal" href="#optimization-direct-execution">Optimization: Direct Execution</a></li>
<li><a class="reference internal" href="#foreign-thread-context-vs-request-context">Foreign Thread Context vs. Request Context</a></li>
<li><a class="reference internal" href="#request-priority">Request Priority</a></li>
<li><a class="reference internal" href="#old-api-backwards-compatibility">Old API Backwards Compatibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-reference">Class Reference</a><ul>
<li><a class="reference internal" href="#request">Request</a></li>
<li><a class="reference internal" href="#requestlock">RequestLock</a></li>
<li><a class="reference internal" href="#simplerequestcondition">SimpleRequestCondition</a></li>
<li><a class="reference internal" href="#requestpool">RequestPool</a></li>
<li><a class="reference internal" href="#id3">ThreadPool</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="advanced.html"
                        title="previous chapter">Advanced Concepts</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="utilities.html"
                        title="next chapter">Utilities</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/request.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="utilities.html" title="Utilities"
             >next</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Advanced Concepts"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">lazyflow 0.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, Christoph Straehle, Bernhard X. Kausler, Thorben Kröger, Ullrich Köthe , Fred A. Hamprecht, Anna Kreshuk, Luca Fiaschi, Stuart Berg.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.8.
    </div>
  </body>
</html>